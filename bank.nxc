/*
Watch out for buffer overflows!!!
Optional: currencies, i18n 
*/

#define ACCOUNTS_FILENAME "konten.txt"
#define CURRENCY="sFr"

byte pressedButton;
int selectButton;      
int arraycount=5;      

struct account {
int accountno;
int pinno;
string lastname;
string firstname;
string title;
int amount;
bool active;
//int dailyout;
};

//initiated list of accounts, start at 0
account accountlist[64]; 


// === Functions & Operations ===

// taken from NXTmenu.nxc
//is it necessary to pass by reference here?
void waitButton() {                
byte wbIndex=BTNRIGHT;
while (wbIndex <= BTNCENTER)   {                         
	if (ButtonPressed(wbIndex,false) != 0)
      		break;                                
        	wbIndex++;                            
	if (wbIndex > BTNCENTER)              
		    wbIndex = BTNRIGHT;                   
}                                     
until(!ButtonPressed(wbIndex,FALSE));   
pressedButton = wbIndex;                
} 

void createAccount() {
//increase the count for arrays for next empty slot
arraycount++;
account pending;
bool check=false;
string checkpin;
int trypin=Random(9999);

// really fucking ugly
while (!check) {

checkpin=NumToStr(trypin);
if (checkpin[0]==0 || checkpin[0]==5 || checkpin[0]==6 || checkpin[0]==7 ||	checkpin[0]==8 || checkpin[0]==9 ||
	checkpin[1]==0 || checkpin[1]==5 || checkpin[1]==6 || checkpin[1]==7 || checkpin[1]==8 || checkpin[1]==9 || 
    checkpin[2]==0 || checkpin[2]==5 ||	checkpin[2]==6 || checkpin[2]==7 || checkpin[2]==8 || checkpin[2]==9 ||
	checkpin[3]==0 || checkpin[3]==5 ||	checkpin[3]==6 || checkpin[3]==7 ||	checkpin[3]==8 || checkpin[3]==9 ) { 
	trypin=Random(9999); 
} else {
    check=true;
}

}

pending.pinno = trypin;
TextOut(0,LCD_LINE1,"Pin number:");
NumOut(0,LCD_LINE2,pending.pinno);
accountlist[arraycount]=pending;
}

void closeAccount(int accountno) {
account closeme=accountlist[accountno];
if (closeme.amount>0) {
	TextOut(0,LCD_LINE1,"Still money in account");
	TextOut(0,LCD_LINE2,"Withdraw it first");
    Wait(3000);
} else {
	closeme.active=FALSE;
	//needed to pass?
	accountlist[accountno]=closeme;
	TextOut(0,LCD_LINE2,"Set inactive");
    //TODO: VERIFY THAT IT IS CHECKED ON WITHDRAW!
    Wait(3000);
}


}

void additionalFunds(int accountno) {
//does not check what is still given
account addfunds=accountlist[accountno];
int amount=100;
NumOut(0,LCD_LINE2,amount);
TextOut(0,LCD_LINE1,"Updated, balance:");
if (pressedButton==BTNLEFT) {
    amount+=100;
    TextOut(0,LCD_LINE1,"Add funds:");
    NumOut(0,LCD_LINE2,amount); //hier W채hrung anh채ngen, wie?
}
if (pressedButton==BTNRIGHT) {
    amount -=100;
    TextOut(0,LCD_LINE1,"Add funds:");
    NumOut(0,LCD_LINE2,amount); //hier W채hrung anh채ngen, wie?
}
if (pressedButton==BTNCENTER) {
    //hier muss es das account value field sein statt account
    addfunds.amount+=amount;
    if (addfunds.active==true) {
        accountlist[accountno]=addfunds;
        TextOut(0,LCD_LINE1,"Updated, balance:");
        NumOut(0,LCD_LINE2,addfunds.amount);
    } else {
    TextOut(0,LCD_LINE1,"Sorry, inactive account");
    }
}

}

void getAccountNo(int &accountno) {
//remove later
accountno=3;
TextOut(0,LCD_LINE1,"Account number:");
NumOut(0,LCD_LINE2,accountno);
while (true) {
	waitButton();
	if (pressedButton==BTNLEFT) {
		accountno--;
		TextOut(0,LCD_LINE1,"Account number:");
		NumOut(0,LCD_LINE2,accountno);
	}
	
	if (pressedButton==BTNRIGHT) {
		accountno++;
		TextOut(0,LCD_LINE1,"Account number:");
		NumOut(0,LCD_LINE2,accountno);
	}
	
	if (pressedButton==BTNCENTER) {
		break; 
		//reicht ein break?
	}
}
}

// === Network Communication ===

task networkListener() {
//ReceiveRemoteString(queue,true, constring);
//somehow get account,pin,amount from listener by extracting on X
//for now static
string request="03X1234X0050";
string tc,tp,ta;
tc=SubStr(request,0,2);
int scard=StrToNum(tc);
tp=SubStr(request,3,4);
int spin=StrToNum(tp);
ta=SubStr(request,9,4);
int samount=StrToNum(ta);

account person=accountlist[scard];
//typematchfail?!
int cpin=person.pinno;
int camt=person.amount;
if (spin == cpin) {
    if (samount>= camt) {
    person.amount-=samount;
	//SendResponseString(queue,"ack");
	//wird das array aktualisiert?
    } else {
	//SendResponseString(queue,"amt");
    }
    } else {
	//SendResponseString(queue,"pin");
	//TODO:possibly count failed pin attempts
    }
}

// === Mechanical Operations ===

//*insert vaporware here*

// === File I/O ===
/* copied from NXC Guide & modified

void startfile() {
//open file to read
FileOpenType foArgs;
foArgs.Filename = ACCOUNTS_FILENAME;
SysFileOpenRead(foArgs); // open the file for reading
if (foArgs.Result == NO_ERR) {
// read data from the file using FileHandle

}

for (i in buffer) {
account tempaccount;
tempaccount.pin //etc, irate through byte
accountlist[i]=tempaccount;
}

}
*/




void shutdownfile() {
//missing
FileOpenType foArgs;
foArgs.Filename = ACCOUNTS_FILENAME;
foArgs.Length = 256; // create with capacity for 256 bytes
SysFileOpenWrite(foArgs); // create the file
if (foArgs.Result == NO_ERR) {
	TextOut(0,LCD_LINE1,"Saved data, close program");
}
}

// === UI ===

void menu() {

bool mstate=true;

int i=0;
while (mstate) {
if (i > 2) i=0;
if (i < 0) i=2;

if (i==0) {
ClearScreen();
Textout(0,LCD_LINE1,"Update Balance");
} else if (i==1) {
ClearScreen();
Textout(0,LCD_LINE1,"Create account");
} else if (i==2) {
ClearScreen();
Textout(0,LCD_LINE1,"Close account");
}

waitButton();
switch (pressedButton) {
case BTNRIGHT: i++;
	break;
case BTNLEFT: i--;
	break;
case BTNCENTER: if (i==0) {
	int accountno=0;
	getAccountNo(accountno);
	additionalFunds(accountno);
	} else if (i==2) {
	int accountno=0;
	getAccountNo(accountno);
	closeAccount(accountno);
	} else if (i==1) {
	createAccount();
	}
    //breakt der hier korrekt?
    mstate=false;
	break;
    }

}

}

// ===Main===

task main() {
SetBrickDataName("Mainframe");

account testperson=accountlist[0];
testperson.accountno=3;
testperson.amount=1000;
testperson.pinno=1212;
testperson.lastname="Egli";

//instantiate bank accounts (from file)
//endless loop
	//start 3 listener for bluetooth connection AND keyboardlistener
	// table locking equivalent?
bool kill=FALSE;
while (!kill) {
    menu();
}

}
